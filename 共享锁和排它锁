并发
select for update:   //加了表级共享锁  行级独占锁
该语句用来锁定特定的行（如果有where子句，就是满足where条件的那些行）。当这些行被锁定后，其他会话可以选择这些行，但不能更改或删除这些行，直到该语句的事务被commit语句或rollback语句结束为止。
原理是:默认情况下的for update语句，效果相当于启动了一个会话级别的事务，在对应的数据表（select所涉及的所有数据表）上加入一个数据表级共享锁（TM，lmode=3）。同时，在对应的数据行中加入独占锁（TX，lmode=6）。
如果此时有另一个会话试图获取对应数据行的独占权限（无论是用update/delete还是另一个for update），都会以block而告终。

什么时候需要使用for update？
就是那些需要业务层面数据独占时，可以考虑使用for update。场景上，比如火车票订票，在屏幕上显示邮票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。这是统一的解决方案方案问题，需要前期有所准备



mysql索引之三：索引使用注意规则（索引失效--存在索引但不使用索引）*
使用索引时，有以下一些技巧和注意事项：
(1)越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。  ///数据类型越小,存储所需空间就越小,处理起来就快 ,是这个道理啊
(2)简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。
(3)尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。
(4)索引不会包含有NULL值的列。

索引失效的原因?
但是如果是同样的sql如果在之前能够使用到索引，那么现在使用不到索引，以下几种主要情况:
1. 随着表的增长，where条件出来的数据太多，大于15%，使得索引失效（会导致CBO计算走索引花费大于走全表）  ///原来是CBO计算得出走全表更好
2. 统计信息失效      需要重新搜集统计信息
3. 索引本身失效      需要重建索引
