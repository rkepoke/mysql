1:磁盘IO与预读    ////讲了很重要的两点.1:    磁盘读取数据依靠的是机械运动,分了寻道时间,旋转时间,传输时间,这三个部分的耗时大概是访问内存的十万倍,因为操作IO是非常昂贵的操作,所以操作系统做了优化,预读.2:根据局部性原理去预读,局部性原理:当访问到一个数据的时候,其相邻的数据也会很快被访问到,所以我们一般读取的是一块一块的数据,每次磁盘IO读取的数据都是一页,
磁盘读取依靠的是机械运动，分为寻道时间、旋转延迟、传输时间三个部分，这三个部分耗时相加就是一次磁盘IO的时间，大概9ms左右。这个成本是访问内存的十万倍左右；正是由于磁盘IO是非常昂贵的操作，所以计算机操作系统对此做了优化：预读；每一次IO时，不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据也加载到内存缓冲区中。因为局部预读原理说明：当访问一个地址数据的时候，与其相邻的数据很快也会被访问到。每次磁盘IO读取的数据我们称之为一页（page）。一页的大小与操作系统有关，一般为4k或者8k。这也就意味着读取一页内数据的时候，实际上发生了一次磁盘IO。


B-Tree与二叉查找树的对比   ///二叉树的查询时间复杂度已经非常优秀了,为什么还要B-Tree?为了减少IO次数,我们之前也说了IO的耗费是很昂贵的,所以减少了IO的次数就是提升了效率,节约了系统资源.
////因为索引也是存储在磁盘上的,那么随着数据的增加,索引也会越来越大,我们不可能把索引全部加载到内存中,只能逐一加载每个磁盘页,这里的磁盘页就是对应的索引树的节点,   ////所以要减少IO次数就要压缩树的高度.
　　我们知道二叉查找树查询的时间复杂度是O（logN），查找速度最快和比较次数最少，既然性能已经如此优秀，但为什么实现索引是使用B-Tree而不是二叉查找树，关键因素是磁盘IO的次数。

数据库索引是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个G甚至更多。当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，这里的磁盘页就对应索引树的节点。

 
B+Tree     重点:////B+树的好处.1:IO次数减少(因为单节点可以存储更多元素).2:因为每次访问数据都要到叶节点,所以B+树的查询很稳定,而B树/B-树的查询结果可能在根节点,也可能在叶节点不稳定
这个过程看下来，貌似与B树的查询过程没有什么区别。但实际上有两点不一样：

a、首先B+树的中间节点不存储卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素，如此一来，相同数量的数据下，B+树就相对来说要更加矮胖些，磁盘IO的次数更少。

b、由于只有叶子节点才保存卫星数据，B+树每次查询都要到叶子节点；而B树每次查询则不一样，最好的情况是根节点，最坏的情况是叶子节点，没有B+树稳定。



总结     这个总结就很好,包含了很多细节
1.单节点可以存储更多的元素，使得查询磁盘IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。

PS:在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。
